# Consider adopting resource naming conventions like these: 
#
#https://confluence.huit.harvard.edu/display/CLA/Cloud+Resource+Naming+Conventions?desktop=true&macroName=livesearch

Description: PeTal DynamoDB table and REST API
Parameters:
  GccTenantOperatorBoundaryArn:
    Type: String
    Description: ARN for gcc-tenantOperatorBoundary Policy
  APIDocVersion:
    Type: Number
    MinValue: 1
    Default: 1
    Description: (For Change Sets) To publish a new version of the API documentation, add 1 to the integer below.
  Environment:
    Type: String
    AllowedValues:
      - br
      - test
    Description: br, test, or empty for prod.
Resources:

  ##############
  #  DynamoDB  #
  ##############

  myDynamoDBTable:
    Type: AWS::DynamoDB::Table
    Properties:
      AttributeDefinitions:
        -
          AttributeName: "PartitionKey"
          AttributeType: "S"
        -
          AttributeName: "SortKey"
          AttributeType: "S"
      KeySchema:
        -
          AttributeName: "PartitionKey"
          KeyType: "HASH"
        -
          AttributeName: "SortKey"
          KeyType: "RANGE"
      ProvisionedThroughput:
        ReadCapacityUnits: 25
        WriteCapacityUnits: 25

  #################
  #  API Gateway  #
  #################

  myRole:
    Type: AWS::IAM::Role
    Properties: 
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
        - Sid: ''
          Effect: Allow
          Principal:
            Service: apigateway.amazonaws.com
          Action: sts:AssumeRole
      Description: Allows API Gateway read data from dynamodb table
      ManagedPolicyArns:
        - !Sub "arn:${AWS::Partition}:iam::aws:policy/AmazonDynamoDBReadOnlyAccess"
        - !Sub "arn:${AWS::Partition}:iam::aws:policy/service-role/AmazonAPIGatewayPushToCloudWatchLogs"
      PermissionsBoundary:
        Ref: GccTenantOperatorBoundaryArn
  myRestApi:
    Type: AWS::ApiGateway::RestApi
    Properties: 
      MinimumCompressionSize: 860
      EndpointConfiguration: 
        Types:
        - EDGE
      Name: !Sub '${Environment}PetalApi'
  myRestApiDocumentationPart:
    Type: AWS::ApiGateway::DocumentationPart
    Properties:
      Location:
        Type: API
      RestApiId: !Ref myRestApi
      # Currently these values are overwritten when exporting the Swagger or OpenAPI spec from API Gateway.
      # They need to be updated manually in the exported yaml file.
      # Also remove the slash in servers:variables:basePath:default in the yaml file.
      Properties: !Sub '{"info": {"title":"PeTaL API Documentation","version":"v${APIDocVersion}"}}'
  myResource:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId:
        Ref: myRestApi
      ParentId:
        Fn::GetAtt:
        - myRestApi
        - RootResourceId
      PathPart: getarticles
  myRequestValidator:
    Type: AWS::ApiGateway::RequestValidator
    Properties: 
      RestApiId:
        Ref: myRestApi
      ValidateRequestBody: false
      ValidateRequestParameters: true
  myGet:
    Type: AWS::ApiGateway::Method
    Properties:
      AuthorizationType: NONE
      HttpMethod: GET
      ResourceId:
        Ref: myResource
      RestApiId:
        Ref: myRestApi
      MethodResponses:
      - ResponseModels:
          application/json: Empty
        StatusCode: 200
      RequestParameters:
        method.request.querystring.level3: true
      RequestValidatorId:
        Ref: myRequestValidator
      Integration:
        Type: AWS
        IntegrationHttpMethod: POST
        Credentials: !GetAtt myRole.Arn
        PassthroughBehavior: WHEN_NO_TEMPLATES
        Uri: !Sub "arn:aws:apigateway:${AWS::Region}:dynamodb:action/Query"
        RequestParameters:
          integration.request.querystring.level3: method.request.querystring.level3
        IntegrationResponses:
        - StatusCode: 200
        RequestTemplates:
          application/json: !Sub
            - |
              #*
                VTL mapping template for API Gateway integration request
                Help articles:
                https://www.alexdebrie.com/posts/api-gateway-elements/#writing-mapping-templates-with-vtl
                https://velocity.apache.org/engine/2.1/vtl-reference.html#comments
                https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_Query.html
                https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-mapping-template-reference.html
              *#

              #set($sanitizedLevel3 = $util.escapeJavaScript($input.params('level3')))

              {
                "TableName": "${myDynamoDBTable}",
                "KeyConditionExpression": "PartitionKey = :v1",
                "ExpressionAttributeValues": {
                  ":v1": {
                    "S": "LABEL-$sanitizedLevel3"
                  }
                }
              }
            - { myDynamoDBTable: !Ref myDynamoDBTable }
  myGetDocumentationPart:
    Type: AWS::ApiGateway::DocumentationPart
    Properties:
      Location:
        Type: METHOD
        Path: /getarticles
      RestApiId: !Ref myRestApi
      Properties: '{"summary": "Finds articles by label","description": "Find articles with the level3 label supplied. Label supplied should be all lowercase, with spaces converted to underscores.","tags":["API methods"]}'
  myQPDocumentationPart:
    Type: AWS::ApiGateway::DocumentationPart
    Properties:
      Location:
        Type: QUERY_PARAMETER
        Path: /getarticles
        Method: GET
        Name: level3
      RestApiId: !Ref myRestApi
      Properties: '{"description": "The third level label to retreive articles for."}'
  myResponseDocumentationPart:
    Type: AWS::ApiGateway::DocumentationPart
    Properties:
      Location:
        Type: RESPONSE
        Path: /getarticles
        Method: GET
        StatusCode: 200
      RestApiId: !Ref myRestApi
      Properties: '{"description": "successful operation"}'
  myResource2:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId:
        Ref: myRestApi
      ParentId:
        Fn::GetAtt:
        - myRestApi
        - RootResourceId
      PathPart: getalllabels
  myGet2:
    Type: AWS::ApiGateway::Method
    Properties:
      AuthorizationType: NONE
      HttpMethod: GET
      ResourceId:
        Ref: myResource2
      RestApiId:
        Ref: myRestApi
      MethodResponses:
      - ResponseModels:
          application/json: Empty
        StatusCode: 200
        ResponseParameters:
            method.response.header.Access-Control-Allow-Origin: false
      Integration:
        Type: AWS
        IntegrationHttpMethod: POST
        Credentials: !GetAtt myRole.Arn
        PassthroughBehavior: WHEN_NO_TEMPLATES
        Uri: !Sub "arn:aws:apigateway:${AWS::Region}:dynamodb:action/Query"
        IntegrationResponses:
        - StatusCode: 200
          ResponseParameters:
            method.response.header.Access-Control-Allow-Origin: "'*'"
        RequestTemplates:
          application/json: !Sub
            - |
              {
                "TableName": "${myDynamoDBTable}",
                "KeyConditionExpression": "PartitionKey = :v1 AND begins_with( SortKey, :v1 )",
                "ExpressionAttributeValues": {
                  ":v1": {
                    "S": "LABEL"
                  }
                }
              }
            - { myDynamoDBTable: !Ref myDynamoDBTable }
  myGet2DocumentationPart:
    Type: AWS::ApiGateway::DocumentationPart
    Properties:
      Location:
        Type: METHOD
        Path: /getalllabels
      RestApiId: !Ref myRestApi
      Properties: '{"summary": "Get all labels","tags":["API methods"]}'
  myResponseDocumentationPart2:
    Type: AWS::ApiGateway::DocumentationPart
    Properties:
      Location:
        Type: RESPONSE
        Path: /getalllabels
        Method: GET
        StatusCode: 200
      RestApiId: !Ref myRestApi
      Properties: '{"description": "successful operation"}'
  myRestApiDocumentationVersion:
    Type: AWS::ApiGateway::DocumentationVersion
    Properties:
      DocumentationVersion: !Ref APIDocVersion
      RestApiId: !Ref myRestApi
    DependsOn: myRestApiDocumentationPart

  #############
  #  Lambdas  #
  #############

  myLambdaPolicy:
    Type: 'AWS::IAM::ManagedPolicy'
    Properties:
      ManagedPolicyName: petal-lambda-dynamodb
      PolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Action:
              - 'dynamodb:BatchWriteItem'
              - 'dynamodb:PutItem'
              - 'dynamodb:Scan'
              - 'dynamodb:Query'
              - 'dynamodb:UpdateItem'
            Resource:
              - !GetAtt myDynamoDBTable.Arn
  myLambdaRole:
    Type: AWS::IAM::Role
    Properties: 
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          Effect: Allow
          Principal:
            Service: lambda.amazonaws.com
          Action: sts:AssumeRole
      Description: Allows Lambda functions to call AWS services on your behalf.
      ManagedPolicyArns:
        - !Sub "arn:${AWS::Partition}:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole"
        - !Sub "arn:${AWS::Partition}:iam::aws:policy/AmazonSageMakerFullAccess"
      PermissionsBoundary:
        Ref: GccTenantOperatorBoundaryArn
  myLambdaPredictRole:
    Type: AWS::IAM::Role
    Properties: 
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          Effect: Allow
          Principal:
            Service: lambda.amazonaws.com
          Action: sts:AssumeRole
      Description: Allows Lambda functions to call AWS services on your behalf.
      ManagedPolicyArns:
        - !Sub "arn:${AWS::Partition}:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole"
        - !Sub "arn:${AWS::Partition}:iam::aws:policy/AmazonSageMakerFullAccess"
        - !Ref myLambdaPolicy
      PermissionsBoundary:
        Ref: GccTenantOperatorBoundaryArn
  mySageMakerRole:
    Type: AWS::IAM::Role
    Properties: 
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          Effect: Allow
          Principal:
            Service: sagemaker.amazonaws.com
          Action: sts:AssumeRole
      Description: Allows Sagemaker to access AWS services.
      ManagedPolicyArns:
        - !Sub "arn:${AWS::Partition}:iam::aws:policy/AmazonS3ReadOnlyAccess"
        - !Sub "arn:${AWS::Partition}:iam::aws:policy/AmazonSageMakerFullAccess"
      PermissionsBoundary:
        Ref: GccTenantOperatorBoundaryArn  
  lambdaModelDeploy:
    Type: 'AWS::Lambda::Function'
    Properties:
      Handler: index.handler
      Runtime: python3.8
      Code:
        ZipFile: !Sub
          - |
            import boto3
            from botocore.exceptions import ClientError

            client = boto3.client('sagemaker')
            role = "${mySageMakerRole}"
            prefix = 'testPyTorch'
            modelName = prefix + 'Model'
            endpointName = prefix + 'Endpoint'
            endpointConfigName = endpointName + 'Config'

            def createModel():
                try: #1
                    client.create_model(
                        ModelName=modelName,
                        PrimaryContainer={
                            'Image': '763104351884.dkr.ecr.us-east-2.amazonaws.com/pytorch-inference-eia:1.5.1-cpu-py36-ubuntu16.04',
                            'ModelDataUrl': 's3://petal-bucket/model.tar.gz'
                        },
                        ExecutionRoleArn=role
                    )
                except ClientError as e:
                  if "Cannot create already existing" in e.response['Error']['Message']:
                    print(e)
                    print('Looks like Model already exists, so ignore error and continue.')
                  else:
                    print(e)
                    print('Unable to create model.')
                    raise(e)

            def createEndpointConfig():
                try:
                    client.create_endpoint_config(
                        EndpointConfigName=endpointConfigName,
                        ProductionVariants=[
                            {
                                'VariantName': 'prod',
                                'ModelName': modelName,
                                'InitialInstanceCount': 1,
                                'InstanceType': 'ml.t2.medium'
                            }
                        ]
                    )
                except ClientError as e:
                  if "Cannot create already existing" in e.response['Error']['Message']:
                    print(e)
                    print('Looks like EndpointConfig already exists, so ignore error and continue.')
                  else:
                    print(e)
                    print('Unable to create endpoint configuration.')
                    raise(e)

            def createEndpoint():
                try:
                    client.create_endpoint(
                        EndpointName=endpointName,
                        EndpointConfigName=endpointConfigName
                    )
                except ClientError as e:
                  if "Cannot create already existing" in e.response['Error']['Message']:
                    print(e)
                    print('Looks like Endpoint already exists, so ignore error and continue.')
                  else:
                    print(e)
                    print('Unable to create endpoint.')
                    raise(e)

            def handler(event, context):
                createModel()
                createEndpointConfig()
                createEndpoint()
                event['stage'] = 'Deployment'
                event['status'] = 'Creating'
                event['message'] = 'Started deploying model "{}" to endpoint "{}"'.format(modelName, endpointName)
                return event
          - { mySageMakerRole: !GetAtt mySageMakerRole.Arn }
      Description: 'Deploys pretrained ML model saved in S3 to Sagemaker'
      Role: !GetAtt myLambdaRole.Arn
  lambdaModelAwait:
    Type: 'AWS::Lambda::Function'
    Properties:
      Handler: index.handler
      Runtime: python3.8
      Code:
        ZipFile: |
          import boto3
          client = boto3.client('sagemaker')

          def handler(event, context):
              stage = event['stage']
              if stage == 'Deployment':
                  prefix = 'testPyTorch'
                  name = prefix + 'Endpoint'
                  endpoint_details = describe_endpoint(name)
                  status = endpoint_details['EndpointStatus']
                  if status == 'InService':
                      event['message'] = 'Deployment completed for endpoint "{}".'.format(name)
                  elif status == 'Failed':
                      failure_reason = endpoint_details['FailureReason']
                      event['message'] = 'Deployment failed for endpoint "{}". {}'.format(name, failure_reason)
                  elif status == 'RollingBack':
                      event['message'] = 'Deployment failed for endpoint "{}", rolling back to previously deployed version.'.format(name)
              event['status'] = status
              return event

          def describe_endpoint(name):
              """ Describe SageMaker endpoint identified by input name.
              Args:
                  name (string): Name of SageMaker endpoint to describe.
              Returns:
                  (dict)
                  Dictionary containing metadata and details about the status of the endpoint.
              """
              try:
                  response = client.describe_endpoint(
                      EndpointName=name
                  )
              except Exception as e:
                  print(e)
                  print('Unable to describe endpoint.')
                  raise(e)
              return response    
      Description: 'Checks for a successful Sagemaker endpoint deployment.'
      Role: !GetAtt myLambdaRole.Arn
  lambdaModelPredict:
    Type: 'AWS::Lambda::Function'
    Properties:
      Handler: index.handler
      Runtime: python3.8
      #Timeout: 900
      #MemorySize: 1024
      Code:
        ZipFile: !Sub
          - |
            import boto3
            import json

            # grab static variables
            client = boto3.client('sagemaker')
            runtime= boto3.client('runtime.sagemaker')
            prefix = 'testPyTorch'
            endpointName = prefix + 'Endpoint'

            def getNewArticlesFromCORE():
                return

            def batchPredictions():#newArticles):#, endpoint):
                # randomly assign labels to articles.
                # 
                data = {"xvalue": 1}
                response = runtime.invoke_endpoint(EndpointName=endpointName,
                                                          ContentType='application/json',
                                                          Body=json.dumps(data))
                response_body = response['Body'] 
                print(response_body.read())
                #result = json.loads(response['Body'].read().decode())
                #print(result)
                return

            def connectToDBTable():
                dynamodb = boto3.resource('dynamodb', region_name="us-east-2")
                return dynamodb.Table('${myDynamoDBTable}')

            def storeLabelledArticles(labelledArticles, dbTable):
                #2
                with dbTable.batch_writer() as batch:
                    for article in labelledArticles:
                        batch.delete_item(Key={'Level2': article['Level2'], 'Level3': article['Level3']})
                with dbTable.batch_writer() as batch:
                    for article in labelledArticles:
                        batch.put_item(
                            Item={
                                'Level2': article['Level2'],
                                'Level3': article['Level3'],
                                'CoreId': article['CoreId']
                            }
                        )

            def handler(event, context):
                batchPredictions()
                event['status'] = 'Processed records'
                # Deleting Endpoint
                client.delete_endpoint(EndpointName=endpointName)
                return event
          - { myDynamoDBTable: !Ref myDynamoDBTable }
      Description: 'Takes unprocessed CORE articles, labels them with biomimetic functions using a deployed SageMaker endpoint, and saves the labelled articles to DynamoDB.'
      Role: !GetAtt myLambdaPredictRole.Arn

  ####################
  #  Step Functions  #
  ####################

  RoleOnboardingInstall:
    Type: AWS::IAM::Role
    Properties: 
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          Effect: Allow
          Principal:
            Service: states.amazonaws.com
          Action: sts:AssumeRole
      Description: Allows StepFunctions to invoke Lambda functions.
      ManagedPolicyArns:
        - !Sub "arn:${AWS::Partition}:iam::aws:policy/service-role/AWSLambdaRole"
      PermissionsBoundary:
        Ref: GccTenantOperatorBoundaryArn
  StateMachineOnboardingInstall:
    Type: 'AWS::StepFunctions::StateMachine'
    Properties:
      DefinitionString: !Sub
        - |
          {
            "StartAt": "StartDeployment",
            "States": {
              "StartDeployment": {
                "Type": "Task",
                "Resource": "${lambdaModelDeployArn}",
                "Next": "CheckStatusDeployment"
              },
              "CheckStatusDeployment": {
                "Type": "Task",
                "Resource": "${lambdaModelAwaitArn}",
                "ResultPath": "$",
                "Next": "CheckDeploymentBranch"
              },
              "CheckDeploymentBranch": {
                "Type": "Choice",
                "Choices": [
                  {
                    "Or": [{
                        "Variable": "$.status",
                        "StringEquals": "Creating"
                      }
                      ],
                    "Next": "WaitStatusDeployment"
                  },
                  {
                    "Or": [{
                        "Variable": "$.status",
                        "StringEquals": "InService"
                      }
                    ],
                    "Next": "StartPrediction"
                  }
                ]
              },
              "WaitStatusDeployment": {
                "Type": "Wait",
                "Seconds": 60,
                "Next": "CheckStatusDeployment"
              },
              "StartPrediction": {
                "Type": "Task",
                "Resource": "${lambdaModelPredictArn}",
                "End": true
              }
            }
          }
        - { lambdaModelDeployArn: !GetAtt lambdaModelDeploy.Arn, lambdaModelAwaitArn: !GetAtt lambdaModelAwait.Arn, lambdaModelPredictArn: !GetAtt lambdaModelPredict.Arn }
      RoleArn: !GetAtt 'RoleOnboardingInstall.Arn'


  ################################################
  #  Run Lambda on a schedule using EventBridge  #
  ################################################

  # https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-events-rule.html#aws-resource-events-rule--examples
  #ScheduledRule: 
  #  Type: AWS::Events::Rule
  #  Properties: 
  #    Description: "Runs the PeTaL labeller Lambda function on a schedule"
  #    ScheduleExpression: "rate(30 days)"
  #    State: "DISABLED"
  #    Targets: 
  #      - 
  #        Arn: 
  #          Fn::GetAtt: 
  #            - "labelCOREArticles"
  #            - "Arn"
  #        Id: "TargetFunctionV1"
  #PermissionForEventsToInvokeLambda: 
  #  Type: AWS::Lambda::Permission
  #  Properties: 
  #    FunctionName: !Ref "labelCOREArticles"
  #    Action: "lambda:InvokeFunction"
  #    Principal: "events.amazonaws.com"
  #    SourceArn: 
  #      Fn::GetAtt: 
  #        - "ScheduledRule"
  #        - "Arn"
